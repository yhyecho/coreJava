## Annotation注解和内置注解
> Annotation是JDK5.0开始引入的新技术
#### 什么是注解
1. 不是程序本身，可以对程序作出解释
2. 可以被其他程序(比如:编译器等)读取

#### 常用内置注解
* @Override
> 此注解只适用于修饰方法，表示一个方法声明打算重写父类中的另一个方法的声明

> eg:
```java
public class Demo1 /* extends Object */ {

    @Override // 注解说明: 重写了父类的方法
    public String toString() {
        return "";
    }
}
```
* @Deprecated
> 此注解可用于修饰方法、属性、类，表示不鼓励使用这样的元素，通常是因为它很危险或存在更好的选择

> eg:
```java
public class Demo2 {

    @Deprecated
    public static void test1() {
        System.out.println("Deprecated method");
    }

    public static void main(String[] args) {
        Date date = new Date();
        data.parse("yyyy");
        test1(); //不推荐使用
    }
}
```
* @SuppressWarnings
> 用来抑制编译时的警告信息
> eg:
```java
public class Demo3 {

    @SuppressWarnings("all") // 抑制警告信息
    public static void test03 {
        List list = new ArrayList();
        List list2 = new ArrayList();
    }

    // @SuppressWarnings(value={"unchecked","deprecation"}) 可赋值字符串数组
}
```

#### 自定义注解
* 源注解(对注解进行解释)
    * @Target (用于描述注解的使用范围，即被描述的注解可以用在什么地方)

        |取值ElementType|修饰范围|
        |--|--|
        |PACKAGE|package包|
        |TYPE|类、接口、枚举、Annotation类型|
        |CONSTRUCTOR:用于描述构造器,FIELD:用于描述域,METHOD:用于描述方法|类型成员(方法、构造方法、成员变量、枚举值)|
        |LOCAL_VARIABLE:用于描述局部变量,PARAMETER:用于描述参数|方法参数和本地变量|
    * @Retention (表示需要在什么级别保存该注释信息，用于描述注解的生命周期)

        |取值|作用|
        |--|--|
        |SOURCE|在源文件中有效(即源文件保留)|
        |CLASS|在class文件中有效(即class保留)|
        |RUNTIME|在运行时有效(即运行时保留)为Runtime可以反射机制读取|
    * @Documented
    * @Inherited

> eg:
```java
// @Target(value={ElementType.METHOD,ElementType.TYPE}) 
@Target(value=ElementType.METHOD) //修饰方法
@Retention(RetentionPolicy.RUNTIME);
public @interface MyAnnotation01 {
    // 参数类型－参数名 默认值
    String userName() default "";
    int age() default 0; // －1 表示不存在的含义

    String[] schools() default {"huawei", "ali"};
}

public class Demo2 {

    @MyAnnotation01(age=19, userName="yu", schools={"tengx","360"})
    public void test1() {
        
    }
}
```
> eg:
```java
@Target(value=ElementType.METHOD) //修饰方法
@Retention(RetentionPolicy.RUNTIME);
public @interface MyAnnotation02 {
    // 一般注解定义只有一个值时, 默认参数名为value();
    String value();
}
```

#### JVM核心机制（类加载过程、JVM内存分析、反射机制核心原理、常量池理解）

#### 类加载机制
> 加载 －> 链接 －> 初始化

#### JVM核心机制（类加载过程、初始化、主动引用、被动引用、静态初始化块执行顺序

#### JVM核心机制（类加载器、三种类加载器、代理加载模式、双亲委派机制）
* 引导类加载器(bootstrap class loader)
* 扩展类加载器 (extensions class loader)
* 应用程序类加载器 (application class loader)
* 自定义类加载器 

#### JVM核心机制（类加载器、自定义文件系统类加载器、网络自定义类加载器）
* 继承 java.lang.ClassLoader

#### JVM核心机制（类加载器、自定加密解密类加载器）

#### JVM核心机制（线程上下文类加载器、Web服务器类加载机制、OSGI模块开发原理）
* 线程上下文类加载器 (为了抛弃双亲委派加载链模式)
```java
Thread.currentThread.getContextClassLoader();
Thread.currentThread.setContextClassLoader();
```
```java
线程上下文类加载器测试
```
* tomcat服务器的类加载机制
* OSGI原理(面相Java的动态模块系统)
```java
A B C
```

#### 内部类分类介绍（静态内部类详解、成员内部类详解）
* 内部类(Nested Class) 嵌套类
    * 静态内部类
    * 非静态内部类
```java
public class Demo1 {

    // 静态内部类
    private static class StaticNestedClass {

    }
    // 普通内部类(成员内部类)
    private class FieldInnerClass {

    }

    void sayHello() {
        // 方法内部类(局部内部类)
        class LocalClass {
            
        }

        // 匿名内部类
        Runnable runnable = new Runnable() {      // 1. 定义了匿名内部类的类型
            // 2. 创建了匿名内部类的一个实例
            @Override
            public void run() {

            }
        };

    }
}
```
> class文件命名方式: Demo1$StaticNestedClass

* 静态内部类的基本用法
    * 静态内部类可以包含静态成员、非静态成员
    * 静态内部类可以直接调用外部类的静态属性、静态方法，但不能调用外部类的普通属性、普通方法
    * 在不相关的类中, 可以直接创建静态内部类的对象(不需要通过所在外部类)
    * 静态内部类实际上和外部类联系很少，也就是命名空间上的联系
```java
public class Demo2 {

    int c = 5;
    static int d = 10;

    // 静态内部类
    private static class StaticInnerClass {
        int a = 3;
        static int b = 5;

        public void test() {
            System.out.println(d);
            // 静态内部类不能
            System.out.println(c);
        }
    }
}
```
```java
public class Demo3 {

    public static void main(String[] args) {
        
        Outer01.StaticInnerClass osic1 = new Outer01. StaticInnerClass();

        StaticInnerClass osic2 = new StaticInnerClass();
    }
}

public class Outer01 {

    int c = 5;
    static int d = 10;

    // 静态内部类
    static class StaticInnerClass {
        int a = 3;
        static int b = 5;

        public void test() {
            System.out.println(d);
            // 静态内部类不能
            System.out.println(c);
        }
    }
}
```
* 成员内部类的基本用法
    * 成员内部类就像一个成员变量一样存在于外部类
    * 成员内部类可以访问外部类的所有成员(包含: private的)
    * 成员内部类的this指内部类对象本身,要拿到内部类对象可以使用
    外部类名+.this
        * 成员内部类的对象是一定要绑定到一个外部类的对象上的，
        因此，创建成员内部类对象时需要持有外部类对象的引用，因此要先有外部类对象，后有成员内部类对象。
    * 成员内部类不能有静态成员
* 成员内部类对象的创建方式
    * 外部类内部
    ```java
    Inner inner = new Inner();
    ```
    * 外部类外部 
    ```java
    Inner inner = new Outer.new Inner();
    ```
    
```java
public class Demo04 {
    public static void main(String[] args) {

        Outer02 out = new Outer02();
        Outer02.InnerClass ic = out.new InnerClass();
        ic.test();
    }
}
class Outer02 {

    private int a = 3;
    int b = 10;

    public void test() {
        InnerClass ic = new InnerClass();
    }

    // 成员内部类
    class InnerClass {
        int c = 1;
        
        // 成员内部类不能有静态成员或方法, 除非声明未final
        // final static int d = 80; 
        // final static Date date = new Date(); // 编译器无法在编译期确定其值
        void test() {
            System.out.println(a);
            // 成员内部类对象的创建，必须先有外部类对象
            System.out.println("内部类对象" + this);
            // 引用了外部类的对象
            System.out.println("外部类对象" + Outer02.this);
        }
    }
}
```




